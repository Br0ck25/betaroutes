// src/routes/dashboard/data-management/lib/pdf-export.ts
import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import type { Trip } from '$lib/types';
import type { ExpenseRecord } from '$lib/db/types';
import type { MileageRecord } from '$lib/db/types';
import { getVehicleDisplayName } from '$lib/utils/vehicle';
import { SvelteDate } from '$lib/utils/svelte-reactivity';

type Vehicle = { id?: string; name?: string };

// Brand colors from design system
const ORANGE = [246, 138, 46] as [number, number, number]; // #F68A2E
const BLUE = [44, 80, 123] as [number, number, number]; // #2C507B

/**
 * Format currency for display
 */
function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2
  }).format(amount);
}

/**
 * Format date for display
 */
function formatDate(dateString: string): string {
  return SvelteDate.from(dateString).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  });
}

// Small helper to safely read numeric properties from an object
function getNum(obj: Record<string, unknown> | null | undefined, key: string): number {
  if (!obj) return 0;
  const v = obj[key];
  if (typeof v === 'number') return v as number;
  if (typeof v === 'string') return Number(v) || 0;
  return 0;
}

// Logo as base64 (120x120 PNG)
const LOGO_BASE64 =
  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAMAAAAOusbgAAACEFBMVEVMaXEtUXtbeHnbjFY4VIrNlVcrUX2Vg0/ijks1U4oxU3ks';

// Types for cells in autoTable rows
type CellLike =
  | string
  | number
  | { content: string; styles?: Record<string, unknown>; colSpan?: number };

/**
 * Add header to PDF page
 */
function addHeader(doc: jsPDF, title: string, subtitle?: string) {
  doc.setFillColor(...ORANGE);
  doc.rect(0, 0, doc.internal.pageSize.width, 35, 'F');

  // Add logo if available
  try {
    doc.addImage(LOGO_BASE64, 'PNG', doc.internal.pageSize.width - 40, 5, 25, 25);
  } catch {
    // Silently fail if logo can't be added
  }

  doc.setTextColor(255, 255, 255);
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.text(title, 14, 15);

  if (subtitle) {
    doc.setFontSize(11);
    doc.setFont('helvetica', 'normal');
    doc.text(subtitle, 14, 24);
  }

  doc.setTextColor(0, 0, 0);
  return 40; // Return Y position for content start
}

/**
 * Add footer to PDF page
 */
function addFooter(doc: jsPDF, pageNum: number) {
  const pageHeight = doc.internal.pageSize.height;
  doc.setFontSize(9);
  doc.setTextColor(128, 128, 128);
  doc.text(
    `Page ${pageNum} • Generated by Go Route Yourself • ${SvelteDate.now().toLocaleDateString()}`,
    14,
    pageHeight - 10
  );
}

/**
 * Export trips to PDF
 */
export function exportTripsPDF(trips: Trip[], dateFrom?: string, dateTo?: string): Blob {
  const doc = new jsPDF({ orientation: 'landscape' });

  // Header
  const period =
    dateFrom && dateTo
      ? `${formatDate(dateFrom)} to ${formatDate(dateTo)}`
      : dateFrom
        ? `From ${formatDate(dateFrom)}`
        : dateTo
          ? `Through ${formatDate(dateTo)}`
          : 'All Records';

  addHeader(doc, 'Trip Log', period);

  // Calculate totals
  let totalMiles = 0;
  let totalEarnings = 0;
  let totalFuel = 0;
  let totalMaintenance = 0;
  let totalSupplies = 0;
  let totalProfit = 0;

  // Prepare table data
  const tableData: Array<CellLike[]> = trips.map((trip) => {
    const tripObj = trip as unknown as Record<string, unknown>;
    const stops = Array.isArray(tripObj['stops'])
      ? (tripObj['stops'] as unknown[]).map((s) => s as Record<string, unknown>)
      : [];
    const earnings = stops.reduce(
      (sum, stop) =>
        sum +
        (typeof stop['earnings'] === 'number'
          ? (stop['earnings'] as number)
          : Number(stop['earnings'] ?? 0) || 0),
      0
    );
    const costs =
      getNum(tripObj, 'fuelCost') +
      getNum(tripObj, 'maintenanceCost') +
      getNum(tripObj, 'suppliesCost');
    const profit = earnings - costs;

    totalMiles += trip.totalMiles || 0;
    totalEarnings += earnings;
    totalFuel += getNum(tripObj, 'fuelCost');
    totalMaintenance += getNum(tripObj, 'maintenanceCost');
    totalSupplies += getNum(tripObj, 'suppliesCost');
    totalProfit += profit;

    return [
      formatDate(trip.date || ''),
      trip.startTime || '-',
      trip.endTime || '-',
      (trip.startAddress || 'Unknown').substring(0, 30) + '...',
      stops.length || 0,
      (trip.totalMiles || 0).toFixed(2),
      formatCurrency(earnings),
      formatCurrency(getNum(tripObj, 'fuelCost')),
      formatCurrency(getNum(tripObj, 'maintenanceCost')),
      formatCurrency(getNum(tripObj, 'suppliesCost')),
      formatCurrency(costs),
      formatCurrency(profit)
    ];
  });

  // Add summary row
  tableData.push([
    { content: 'TOTALS', styles: { fontStyle: 'bold' } } as CellLike,
    '',
    '',
    '',
    trips.length.toString(),
    { content: totalMiles.toFixed(2), styles: { fontStyle: 'bold' } } as CellLike,
    { content: formatCurrency(totalEarnings), styles: { fontStyle: 'bold' } } as CellLike,
    { content: formatCurrency(totalFuel), styles: { fontStyle: 'bold' } } as CellLike,
    { content: formatCurrency(totalMaintenance), styles: { fontStyle: 'bold' } } as CellLike,
    { content: formatCurrency(totalSupplies), styles: { fontStyle: 'bold' } } as CellLike,
    {
      content: formatCurrency(totalFuel + totalMaintenance + totalSupplies),
      styles: { fontStyle: 'bold' }
    } as CellLike,
    { content: formatCurrency(totalProfit), styles: { fontStyle: 'bold' } } as CellLike
  ]);

  // Create table
  autoTable(doc, {
    startY: 45,
    head: [
      [
        'Date',
        'Start',
        'End',
        'Start Address',
        'Stops',
        'Miles',
        'Earnings',
        'Fuel',
        'Maint.',
        'Supplies',
        'Total Cost',
        'Net Profit'
      ]
    ],
    body: tableData,
    headStyles: {
      fillColor: ORANGE,
      textColor: [255, 255, 255],
      fontStyle: 'bold',
      fontSize: 9
    },
    theme: 'striped',
    styles: { fontSize: 8, cellPadding: 2 },
    columnStyles: {
      3: { cellWidth: 40 },
      6: { halign: 'right' },
      7: { halign: 'right' },
      8: { halign: 'right' },
      9: { halign: 'right' },
      10: { halign: 'right' },
      11: { halign: 'right' }
    }
  });

  addFooter(doc, 1);

  return doc.output('blob');
}

/**
 * Export expenses to PDF
 */
export function exportExpensesPDF(
  expenses: ExpenseRecord[],
  dateFrom?: string,
  dateTo?: string
): Blob {
  const doc = new jsPDF();

  // Header
  const period =
    dateFrom && dateTo
      ? `${formatDate(dateFrom)} to ${formatDate(dateTo)}`
      : dateFrom
        ? `From ${formatDate(dateFrom)}`
        : dateTo
          ? `Through ${formatDate(dateTo)}`
          : 'All Records';

  addHeader(doc, 'Expense Log', period);

  // Calculate totals by category
  const totalByCategory: Record<string, number> = {};
  let grandTotal = 0;

  expenses.forEach((expense) => {
    totalByCategory[expense.category] = (totalByCategory[expense.category] || 0) + expense.amount;
    grandTotal += expense.amount;
  });

  // Prepare table data
  const tableData: Array<CellLike[]> = expenses.map((expense) => [
    formatDate(expense.date),
    expense.category,
    formatCurrency(expense.amount),
    expense.description || '-'
  ]);

  // Add category totals
  tableData.push(['', '', '', '']);
  tableData.push([
    { content: 'CATEGORY TOTALS', colSpan: 2, styles: { fontStyle: 'bold' } } as CellLike,
    '',
    '',
    ''
  ]);

  Object.entries(totalByCategory).forEach(([category, total]) => {
    tableData.push([
      '',
      category,
      { content: formatCurrency(total), styles: { fontStyle: 'bold' } } as CellLike,
      ''
    ]);
  });

  // Add grand total
  tableData.push(['', '', '', '']);
  tableData.push([
    {
      content: 'GRAND TOTAL',
      colSpan: 2,
      styles: { fontStyle: 'bold', fillColor: ORANGE, textColor: [255, 255, 255] }
    },
    '',
    {
      content: formatCurrency(grandTotal),
      styles: { fontStyle: 'bold', fillColor: ORANGE, textColor: [255, 255, 255] }
    },
    ''
  ]);

  // Create table
  autoTable(doc, {
    startY: 45,
    head: [['Date', 'Category', 'Amount', 'Description']],
    body: tableData,
    headStyles: {
      fillColor: ORANGE,
      textColor: [255, 255, 255],
      fontStyle: 'bold'
    },
    theme: 'striped',
    styles: { fontSize: 10 },
    columnStyles: {
      0: { cellWidth: 30 },
      1: { cellWidth: 35 },
      2: { cellWidth: 30, halign: 'right' },
      3: { cellWidth: 'auto' }
    }
  });

  addFooter(doc, 1);

  return doc.output('blob');
}

/**
 * Export mileage to PDF (IRS-compliant format)
 */
export function exportMileagePDF(
  mileageLogs: MileageRecord[],
  vehicles?: Vehicle[],
  dateFrom?: string,
  dateTo?: string
): Blob {
  const doc = new jsPDF();

  // Header
  const period =
    dateFrom && dateTo
      ? `${formatDate(dateFrom)} to ${formatDate(dateTo)}`
      : dateFrom
        ? `From ${formatDate(dateFrom)}`
        : dateTo
          ? `Through ${formatDate(dateTo)}`
          : 'All Records';

  addHeader(doc, 'Mileage Log - IRS Compliant', period);

  // Calculate totals
  const totalMiles = mileageLogs.reduce((sum, log) => sum + log.miles, 0);
  const mileageRate = 0.725; // 2026 IRS standard rate
  const estimatedDeduction = totalMiles * mileageRate;

  // Prepare table data
  const tableData = mileageLogs.map((log) => [
    formatDate(log.date || ''),
    getVehicleDisplayName(log.vehicle, vehicles),
    (log.startOdometer || 0).toLocaleString(),
    (log.endOdometer || 0).toLocaleString(),
    log.miles.toFixed(2),
    log['purpose'] || 'Business',
    log.notes || '-'
  ]);

  // Add summary row
  tableData.push([
    { content: 'TOTALS', colSpan: 4, styles: { fontStyle: 'bold' } },
    '',
    '',
    '',
    { content: totalMiles.toFixed(2), styles: { fontStyle: 'bold' } },
    '',
    ''
  ]);

  // Create table
  autoTable(doc, {
    startY: 45,
    head: [['Date', 'Vehicle', 'Start Odo', 'End Odo', 'Miles', 'Purpose', 'Notes']],
    body: tableData,
    headStyles: {
      fillColor: ORANGE,
      textColor: [255, 255, 255],
      fontStyle: 'bold'
    },
    theme: 'striped',
    styles: { fontSize: 9 },
    columnStyles: {
      0: { cellWidth: 25 },
      1: { cellWidth: 25 },
      2: { cellWidth: 25, halign: 'right' },
      3: { cellWidth: 25, halign: 'right' },
      4: { cellWidth: 20, halign: 'right' },
      5: { cellWidth: 25 },
      6: { cellWidth: 'auto' }
    }
  });

  // Add summary section
  const finalY =
    (doc as unknown as { lastAutoTable?: { finalY?: number } }).lastAutoTable?.finalY ?? 45;

  doc.setFillColor(...BLUE);
  doc.rect(14, finalY + 10, doc.internal.pageSize.width - 28, 30, 'F');

  doc.setTextColor(255, 255, 255);
  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.text('IRS Standard Mileage Deduction (2026)', 20, finalY + 20);

  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.text(`Total Business Miles: ${totalMiles.toFixed(2)}`, 20, finalY + 28);
  doc.text(`Standard Rate: $${mileageRate.toFixed(3)}/mile`, 20, finalY + 35);

  doc.setFont('helvetica', 'bold');
  doc.text(`Estimated Deduction: ${formatCurrency(estimatedDeduction)}`, 120, finalY + 35);

  doc.setTextColor(0, 0, 0);

  addFooter(doc, 1);

  return doc.output('blob');
}

/**
 * Export comprehensive tax bundle as PDF
 */
export function exportTaxBundlePDF(
  trips: Trip[],
  expenses: ExpenseRecord[],
  mileageLogs: MileageRecord[],
  vehicles?: Vehicle[],
  dateFrom?: string,
  dateTo?: string
): Blob {
  const doc = new jsPDF();

  const period =
    dateFrom && dateTo
      ? `${formatDate(dateFrom)} to ${formatDate(dateTo)}`
      : dateFrom
        ? `From ${formatDate(dateFrom)}`
        : dateTo
          ? `Through ${formatDate(dateTo)}`
          : 'All Records';

  // ============= PAGE 1: TAX SUMMARY =============
  addHeader(doc, 'Tax Summary Report', period);

  doc.setFontSize(10);
  doc.setTextColor(100, 100, 100);
  doc.text(`Generated: ${SvelteDate.now().toLocaleString('en-US')}`, 14, 50);
  let yPos = 60;

  // Income Section (using pay dates)
  doc.setFillColor(...BLUE);
  doc.rect(14, yPos, doc.internal.pageSize.width - 28, 10, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('INCOME (By Pay Date)', 20, yPos + 7);
  doc.setTextColor(0, 0, 0);
  yPos += 15;

  // Calculate income by pay date
  const incomeByMonth: Record<string, number> = {};
  let totalIncome = 0;

  trips.forEach((trip) => {
    const tripObj = trip as unknown as Record<string, unknown>;
    const stops = Array.isArray(tripObj['stops'])
      ? (tripObj['stops'] as unknown[]).map((s) => s as Record<string, unknown>)
      : [];
    const earnings = stops.reduce(
      (sum, stop) =>
        sum +
        (typeof stop['earnings'] === 'number'
          ? (stop['earnings'] as number)
          : Number(stop['earnings'] ?? 0) || 0),
      0
    );
    if (earnings > 0) {
      // Use payDate if available, otherwise use date
      const dateToUse =
        typeof tripObj['payDate'] === 'string' ? (tripObj['payDate'] as string) : trip.date;
      if (dateToUse) {
        const month = SvelteDate.from(dateToUse).toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long'
        });
        incomeByMonth[month] = (incomeByMonth[month] || 0) + earnings;
        totalIncome += earnings;
      }
    }
  });

  doc.setFontSize(10);
  Object.entries(incomeByMonth)
    .sort((a, b) => SvelteDate.from(a[0]).getTime() - SvelteDate.from(b[0]).getTime())
    .forEach(([month, amount]) => {
      doc.text(month, 20, yPos);
      doc.text(formatCurrency(amount), 150, yPos, { align: 'right' });
      yPos += 7;
    });

  doc.setFont('helvetica', 'bold');
  doc.text('Total Income', 20, yPos + 3);
  doc.text(formatCurrency(totalIncome), 150, yPos + 3, { align: 'right' });
  doc.setFont('helvetica', 'normal');
  yPos += 15;

  // Mileage Deduction Section
  doc.setFillColor(...BLUE);
  doc.rect(14, yPos, doc.internal.pageSize.width - 28, 10, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('MILEAGE DEDUCTION', 20, yPos + 7);
  doc.setTextColor(0, 0, 0);
  yPos += 15;

  const totalMiles = mileageLogs.reduce((sum, log) => sum + log.miles, 0);
  const mileageRate = 0.725;
  const mileageDeduction = totalMiles * mileageRate;

  doc.setFontSize(10);
  doc.text(`Total Business Miles: ${totalMiles.toFixed(2)} miles`, 20, yPos);
  yPos += 7;
  doc.text(`Standard Mileage Rate (2026): $${mileageRate.toFixed(3)}/mile`, 20, yPos);
  yPos += 7;
  doc.setFont('helvetica', 'bold');
  doc.text('Estimated Deduction:', 20, yPos);
  doc.text(formatCurrency(mileageDeduction), 150, yPos, { align: 'right' });
  doc.setFont('helvetica', 'normal');
  yPos += 15;

  // Business Expenses Section
  doc.setFillColor(...BLUE);
  doc.rect(14, yPos, doc.internal.pageSize.width - 28, 10, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('BUSINESS EXPENSES', 20, yPos + 7);
  doc.setTextColor(0, 0, 0);
  yPos += 15;

  // Separate deductible and non-deductible expenses
  const deductibleByCategory: Record<string, number> = {};
  const nonDeductibleByCategory: Record<string, number> = {};
  let totalDeductible = 0;
  let totalNonDeductible = 0;

  expenses.forEach((expense) => {
    const isDeductible = expense.taxDeductible !== false; // default to true if not specified
    if (isDeductible) {
      deductibleByCategory[expense.category] =
        (deductibleByCategory[expense.category] || 0) + expense.amount;
      totalDeductible += expense.amount;
    } else {
      nonDeductibleByCategory[expense.category] =
        (nonDeductibleByCategory[expense.category] || 0) + expense.amount;
      totalNonDeductible += expense.amount;
    }
  });

  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.text('Tax Deductible:', 20, yPos);
  yPos += 7;
  doc.setFont('helvetica', 'normal');

  Object.entries(deductibleByCategory).forEach(([category, total]) => {
    doc.text(category, 25, yPos);
    doc.text(formatCurrency(total), 150, yPos, { align: 'right' });
    yPos += 7;
  });

  doc.setFont('helvetica', 'bold');
  doc.text('Deductible Subtotal:', 25, yPos);
  doc.text(formatCurrency(totalDeductible), 150, yPos, { align: 'right' });
  yPos += 10;

  if (Object.keys(nonDeductibleByCategory).length > 0) {
    doc.text('Non-Deductible:', 20, yPos);
    yPos += 7;
    doc.setFont('helvetica', 'normal');

    Object.entries(nonDeductibleByCategory).forEach(([category, total]) => {
      doc.text(category, 25, yPos);
      doc.text(formatCurrency(total), 150, yPos, { align: 'right' });
      yPos += 7;
    });

    doc.setFont('helvetica', 'bold');
    doc.text('Non-Deductible Subtotal:', 25, yPos);
    doc.text(formatCurrency(totalNonDeductible), 150, yPos, { align: 'right' });
    yPos += 10;
  }

  const totalExpenses = totalDeductible + totalNonDeductible;

  doc.setFont('helvetica', 'bold');
  doc.text('Total Expenses', 20, yPos + 3);
  doc.text(formatCurrency(totalExpenses), 150, yPos + 3, { align: 'right' });
  doc.setFont('helvetica', 'normal');
  yPos += 15;

  // Total Deductions Summary
  doc.setFillColor(...ORANGE);
  doc.rect(14, yPos, doc.internal.pageSize.width - 28, 25, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(16);
  doc.setFont('helvetica', 'bold');
  doc.text('TOTAL TAX DEDUCTIONS', 20, yPos + 10);
  doc.setFontSize(20);
  doc.text(
    formatCurrency(mileageDeduction + totalExpenses),
    doc.internal.pageSize.width - 20,
    yPos + 18,
    { align: 'right' }
  );
  doc.setTextColor(0, 0, 0);
  yPos += 35;

  // Important Notes
  doc.setFontSize(9);
  doc.setTextColor(100, 100, 100);
  const notes = [
    'NOTES:',
    '• Income reported by pay date for accurate tax reporting',
    '• This report is for informational purposes only',
    '• Consult with a tax professional for specific advice',
    '• Keep all receipts and documentation for 7 years',
    '• Standard mileage rate may change annually'
  ];

  notes.forEach((note) => {
    if (yPos > 270) {
      doc.addPage();
      yPos = 20;
    }
    doc.text(note, 20, yPos);
    yPos += 5;
  });

  addFooter(doc, 1);

  // ============= PAGE 2: MILEAGE LOG =============
  doc.addPage();
  addHeader(doc, 'Detailed Mileage Log', period);

  const mileageTableData: Array<CellLike[]> = [];
  mileageLogs.forEach((log) => {
    const row: CellLike[] = [
      formatDate(log.date || '') as CellLike,
      getVehicleDisplayName(log.vehicle, vehicles) as CellLike,
      (log.startOdometer || 0).toLocaleString() as CellLike,
      (log.endOdometer || 0).toLocaleString() as CellLike,
      log.miles.toFixed(2) as CellLike,
      (log['purpose'] || 'Business') as CellLike
    ];
    mileageTableData.push(row);
  });

  mileageTableData.push([
    { content: 'TOTAL', colSpan: 4, styles: { fontStyle: 'bold' } } as CellLike,
    '',
    '',
    '',
    { content: totalMiles.toFixed(2), styles: { fontStyle: 'bold' } } as CellLike,
    ''
  ]);

  autoTable(doc, {
    startY: 45,
    head: [['Date', 'Vehicle', 'Start Odo', 'End Odo', 'Miles', 'Purpose']],
    body: mileageTableData,
    headStyles: {
      fillColor: ORANGE,
      textColor: [255, 255, 255],
      fontStyle: 'bold'
    },
    theme: 'striped',
    styles: { fontSize: 9 },
    columnStyles: {
      2: { halign: 'right' },
      3: { halign: 'right' },
      4: { halign: 'right' }
    }
  });

  addFooter(doc, 2);

  // ============= PAGE 3: EXPENSE LOG =============
  doc.addPage();
  addHeader(doc, 'Detailed Expense Log', period);

  const expenseTableData: Array<CellLike[]> = expenses.map((expense) => [
    formatDate(expense.date),
    expense.category,
    formatCurrency(expense.amount),
    expense.description || '-'
  ]);

  expenseTableData.push([
    { content: 'TOTAL', colSpan: 2, styles: { fontStyle: 'bold' } } as CellLike,
    '',
    { content: formatCurrency(totalExpenses), styles: { fontStyle: 'bold' } } as CellLike,
    ''
  ]);

  autoTable(doc, {
    startY: 45,
    head: [['Date', 'Category', 'Amount', 'Description']],
    body: expenseTableData,
    headStyles: {
      fillColor: ORANGE,
      textColor: [255, 255, 255],
      fontStyle: 'bold'
    },
    theme: 'striped',
    styles: { fontSize: 10 },
    columnStyles: {
      2: { halign: 'right' }
    }
  });

  addFooter(doc, 3);

  return doc.output('blob');
}
